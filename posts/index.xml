<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GID</title>
    <link>https://gdetor.github.io/posts/</link>
    <description>Recent content in Posts on GID</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Â© 2024, Georgios Is. Detorakis.</copyright>
    <lastBuildDate>Wed, 23 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://gdetor.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How do we compute a Gramian Angular Field (GAF) for time series?</title>
      <link>https://gdetor.github.io/posts/gaf/</link>
      <pubDate>Wed, 23 Apr 2025 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/gaf/</guid>
      <description>Here, we briefly introduce the Gramian Angular Field (GAF) method proposed by [1] to convert time series into images without losing much information. Thus, we can use those images with deep neural networks and computer vision methods to analyze or classify time series. Following [1], we present the main idea behind GAF: to obtain a matrix of similarities between temporal data points of a time series. To do so, the authors in [1] introduced the following algorithm:</description>
    </item>
    
    <item>
      <title>Tips &amp; Tricks (Linux/Vim/Git/Programming)</title>
      <link>https://gdetor.github.io/posts/tipsntricks/</link>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/tipsntricks/</guid>
      <description>In this post you can find various simple tricks and tips for Linux, Vim, Git, Python and many other stuff. All the material provided in this page has been suggested by many different sources such as Command Line Magic, Mastering Vim, kernel_perspective, nixCraft, and Linux Today. The material is free and can be redistributed and/or modified. There is no any warranty that they work for you or are suitable to your need.</description>
    </item>
    
    <item>
      <title>Eigenvalue level repulsion</title>
      <link>https://gdetor.github.io/posts/eigs_level_repulsion/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/eigs_level_repulsion/</guid>
      <description>Imaging we have two matrices ${\bf A}, {\bf B}$ $\in \mathbb{R}^n$, that are both symmetric. Then, we know that both matrices have $n$ eigenvalues (multiplicity). Let&amp;rsquo;s start now, gradually morphing ${\bf A}$ to ${\bf B}$ using the following formula
$$ {\bf A}[t] = (1 - t) {\bf A} + t {\bf B}, $$
where $t \in [0, 1]$. What will happen is that matrix ${\bf A}$ will have multiple eigenvalues with probability zero, given we have chosen the matrices properly from the set of all real symmetric matrices.</description>
    </item>
    
    <item>
      <title>How do we verify linear separability with Python?</title>
      <link>https://gdetor.github.io/posts/linear_separability/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/linear_separability/</guid>
      <description>Two sets $ A $ and $ B $ in an $ n $ dimensional Euclidean space are linear separable if there exist $ n + 1 $ numbers $ w_i \in \mathbb{R} $ such that every point $ a \in A $ satisfies
$$ \sum_{i=1}^{n}w_i a_i &amp;gt; k, $$
and every point $ b \in B $ satisfies
$$ \sum_{i=1}^{n}w_i b_i &amp;lt; k, $$
where $ k \in \mathbb{R} $ defines a linear border (e.</description>
    </item>
    
    <item>
      <title>Intersection points of curves</title>
      <link>https://gdetor.github.io/posts/curves_intersection/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/curves_intersection/</guid>
      <description>We often need to compute the points where two lines intersect or where a function intersects the x-axis (zero crossing). Here, we provide a Python script that does precisely that. Computes the points where two curves (lines, time series, etc.) intersect.
Hence, we provide a simple Python code that can compute the points $(x, y)$ where two curves, $ f(t) $ and g(t), intersect. The first step, and the easy one, is to take two points, one from each curve, $ (t_1, Y_f) $, and $ (t_1, Y_g) $, compute their distance, and check if it is smaller than an $ \epsilon $, where $ \epsilon $ is a tiny number close to zero.</description>
    </item>
    
    <item>
      <title>Simple mathematical tricks in Python</title>
      <link>https://gdetor.github.io/posts/math_tips/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/math_tips/</guid>
      <description>In this post, you can find some helpful mathematical tips and tricks in the Python programming language.
Positive definite matrix Check if a given matrix $ \bf{A} $ is positive definite. If all the eigenvalues of matrix $ \bf{A} $ are positive then the matrix is positive definite.
$ A = np.array([[1, 2], [2, 1]]) $ print(A) [[1 2] [2 1]] $ np.all(np.linalg.eigvals(A) &amp;gt; 0) False # A is not a positive definite matrix $ A = np.</description>
    </item>
    
    <item>
      <title>An introduction to self-organizing maps</title>
      <link>https://gdetor.github.io/posts/som/</link>
      <pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/som/</guid>
      <description>This post presents the classical self-organizing map algorithm proposed by Grossberg [1] and Teuvo Kohonen [2]. We explain the algorithm&amp;rsquo;s fundamental aspects and applications and offer a basic implementation in Pytorch.
Introduction Let us begin with a prevalent problem in science. We often have to deal with data that live in a high-dimensional space $\mathcal{X} \in \mathbb{R}^k$. When $k &amp;gt; 3$, things get rough for people who need help to visualize what&amp;rsquo;s happening.</description>
    </item>
    
    <item>
      <title>Organs-on-Chip-as-a-Service: A proposal bridging cloud services and scientific experiments</title>
      <link>https://gdetor.github.io/posts/cloudlab/</link>
      <pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/cloudlab/</guid>
      <description>Abstract Technological advancements enable delicate and complex experiments on small-scale devices, such as organs-on-chips, improving and accelerating research. At the same time, an ever-increasing diversity of hardware platforms is accessible via cloud services. This perspective article describes our vision for the future of organs-on-chips. We present the main idea behind organs-on-chips as a cloud service, a brief description of the proposed infrastructure, and some applications.
Keywors Organs-on-chips, tissue-as-a-service, cloud computing, neuroscience, experiments</description>
    </item>
    
    <item>
      <title>Autocorrelation Functions for Time Series</title>
      <link>https://gdetor.github.io/posts/acf_pacf/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/acf_pacf/</guid>
      <description>This post aims to provide some theoretical background on autocorrelation functions and how to use them to analyze time series. Furthermore, we show how to use the Autocorrelation (ACF) function and the Partial Autocorrelation (PACF) function to determine the parameters for an ARMA model.
Brief introduction to time series In a previous post (see here), we introduced some basic definitions and terminology about time series. We repeat the same definitions here to avoid forcing the reader to move back and forth.</description>
    </item>
    
    <item>
      <title>Useful data transformations</title>
      <link>https://gdetor.github.io/posts/normalization/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/normalization/</guid>
      <description>This post briefly introduces fundamental data transformations such as mean subtraction (centering data), normalization, standardization, difference transform, and power transform. Furthermore, we provide simple examples of Python code for applying those transforms to real data. Moreover, we heavily rely on the sklearn Python package [1].
Mean subtraction Let&amp;rsquo;s assume we have some data in a vector $ {\bf x} $, and know that the mean value of $ {\bf x} $ is not zero.</description>
    </item>
    
    <item>
      <title>Time series forecasting error metrics</title>
      <link>https://gdetor.github.io/posts/errors/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/errors/</guid>
      <description>In this post, we will explore the basic error measures used in time-series forecasting. Error measures provide a way to quantify the quality of a forecasting algorithm (e.g., the performance). First, we briefly introduce time series and the fundamental terms of forecasting. Second, we will introduce the most commonly used error measures and give examples. Finally, we provide a complete example of using errors in a real-life forecasting scenario.
What is a time series A time series is a series of data points indexed in time order in layman&amp;rsquo;s terms [1, 2].</description>
    </item>
    
    <item>
      <title>Genetic Algorithms &amp; Island Models</title>
      <link>https://gdetor.github.io/posts/genetic_algorithms/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/genetic_algorithms/</guid>
      <description>In this post, we explore genetic algorithms (GAs) and the so-called island model (IM). GAs and the IM are optimization methods used to maximize or minimize a cost function.
What is Optimization? Let&amp;rsquo;s see an example of an optimization problem we all face every day. Let&amp;rsquo;s assume you&amp;rsquo;d like to go and grab a couple of coffee from your favorite coffee shop. Typically, you ask Google to find the fastest way to the store from your current location.</description>
    </item>
    
    <item>
      <title>Research Demos</title>
      <link>https://gdetor.github.io/posts/demos/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gdetor.github.io/posts/demos/</guid>
      <description>The following videos demonstrate a computation model of primary somatosensory cortex undergoing self-organization. The model relies on Neural Field [1]. The complete mathematical/computational model as well as all the details and results are given in [2] and [3].
 Self-organization of receptive fields (RFs)    Evolution of a single RF during self-organization    Evolution of multiple RFs during self-organization     References  Dynamics of pattern formation in lateral-inhibition type neural fields A Neural Field Model of the Somatosensory Cortex: Formation, Maintenance and Reorganization of Ordered Topographic Maps Structure of receptive fields in a computational model of area 3b of primary sensory cortex  </description>
    </item>
    
  </channel>
</rss>
